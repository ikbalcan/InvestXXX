"""
Paper Trading ve CanlÄ± Sinyal Sistemi
GerÃ§ek zamanlÄ± tahminler ve simÃ¼le edilmiÅŸ iÅŸlemler
"""

import pandas as pd
import numpy as np
import logging
from typing import Dict, List, Optional, Tuple
from datetime import datetime, timedelta
import json
import os
import schedule
import time

logger = logging.getLogger(__name__)

class PaperTrader:
    def __init__(self, config: Dict):
        self.config = config
        self.risk_config = config.get('RISK_MANAGEMENT', {})
        self.telegram_config = config.get('TELEGRAM', {})
        
        # Paper trading parametreleri - localStorage'dan yÃ¼kle
        self.initial_capital = self.load_initial_capital()
        self.current_capital = self.load_current_capital()
        self.positions = self.load_positions()  # {symbol: {'quantity': float, 'entry_price': float, 'entry_date': datetime}}
        self.trade_history = self.load_trade_history()
        
        # Risk yÃ¶netimi
        self.max_position_size = self.risk_config.get('max_position_size', 0.02)
        self.stop_loss_pct = self.risk_config.get('stop_loss_pct', 0.05)
        self.take_profit_pct = self.risk_config.get('take_profit_pct', 0.10)
        self.max_daily_trades = self.risk_config.get('max_daily_trades', 5)
        
        # Fiyat cache sistemi
        self.price_cache = {}  # {symbol: {'price': float, 'timestamp': datetime}}
        self.cache_duration = 300  # 5 dakika cache sÃ¼resi
        
        # Telegram bot
        self.telegram_bot = None
        if self.telegram_config.get('enabled', False):
            try:
                # Telegram bot kodu burada olacak (opsiyonel)
                pass
            except Exception as e:
                logger.warning(f"Telegram bot baÅŸlatÄ±lamadÄ±: {str(e)}")
        
        # Log dosyalarÄ±
        self.log_dir = "logs"
        os.makedirs(self.log_dir, exist_ok=True)
        
        # localStorage dosyasÄ±
        self.local_storage_file = os.path.join(self.log_dir, "paper_trading_localStorage.json")
    
    def load_initial_capital(self) -> float:
        """BaÅŸlangÄ±Ã§ sermayesini localStorage'dan yÃ¼kler"""
        try:
            if hasattr(self, 'local_storage_file') and os.path.exists(self.local_storage_file):
                with open(self.local_storage_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    return data.get('initial_capital', 100000)
        except Exception as e:
            logger.warning(f"localStorage yÃ¼kleme hatasÄ±: {str(e)}")
        return 100000  # VarsayÄ±lan deÄŸer
    
    def load_current_capital(self) -> float:
        """Mevcut sermayeyi localStorage'dan yÃ¼kler"""
        try:
            if hasattr(self, 'local_storage_file') and os.path.exists(self.local_storage_file):
                with open(self.local_storage_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    return data.get('current_capital', 100000)
        except Exception as e:
            logger.warning(f"localStorage yÃ¼kleme hatasÄ±: {str(e)}")
        return 100000  # VarsayÄ±lan deÄŸer
    
    def load_positions(self) -> Dict:
        """PozisyonlarÄ± localStorage'dan yÃ¼kler"""
        try:
            if hasattr(self, 'local_storage_file') and os.path.exists(self.local_storage_file):
                with open(self.local_storage_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    positions = data.get('positions', {})
                    
                    # Datetime objelerini geri yÃ¼kle
                    for symbol, pos in positions.items():
                        pos['entry_date'] = datetime.fromisoformat(pos['entry_date'])
                    
                    return positions
        except Exception as e:
            logger.warning(f"localStorage yÃ¼kleme hatasÄ±: {str(e)}")
        return {}
    
    def load_trade_history(self) -> List:
        """Ä°ÅŸlem geÃ§miÅŸini localStorage'dan yÃ¼kler"""
        try:
            if hasattr(self, 'local_storage_file') and os.path.exists(self.local_storage_file):
                with open(self.local_storage_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    trade_history = data.get('trade_history', [])
                    
                    # Datetime objelerini geri yÃ¼kle
                    for trade in trade_history:
                        trade['date'] = datetime.fromisoformat(trade['date'])
                    
                    return trade_history
        except Exception as e:
            logger.warning(f"localStorage yÃ¼kleme hatasÄ±: {str(e)}")
        return []
    
    def save_to_localStorage(self):
        """Verileri localStorage'a kaydeder"""
        try:
            data = {
                'initial_capital': self.initial_capital,
                'current_capital': self.current_capital,
                'positions': {},
                'trade_history': [],
                'last_updated': datetime.now().isoformat()
            }
            
            # PozisyonlarÄ± JSON serializable hale getir
            for symbol, pos in self.positions.items():
                data['positions'][symbol] = {
                    'quantity': pos['quantity'],
                    'entry_price': pos['entry_price'],
                    'entry_date': pos['entry_date'].isoformat(),
                    'confidence': pos['confidence']
                }
            
            # Trade history'yi JSON serializable hale getir
            for trade in self.trade_history:
                trade_copy = trade.copy()
                trade_copy['date'] = trade['date'].isoformat()
                data['trade_history'].append(trade_copy)
            
            with open(self.local_storage_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, indent=2, ensure_ascii=False)
            
            logger.info(f"Veriler localStorage'a kaydedildi: {self.local_storage_file}")
            
        except Exception as e:
            logger.error(f"localStorage kaydetme hatasÄ±: {str(e)}")
    
    def reset_portfolio(self, new_capital: float = 100000):
        """PortfÃ¶yÃ¼ sÄ±fÄ±rlar"""
        self.initial_capital = new_capital
        self.current_capital = new_capital
        self.positions = {}
        self.trade_history = []
        self.save_to_localStorage()
        logger.info(f"PortfÃ¶y sÄ±fÄ±rlandÄ±. Yeni sermaye: {new_capital:,.0f} TL")
        
    def send_telegram_message(self, message: str) -> bool:
        """Telegram mesajÄ± gÃ¶nderir (opsiyonel)"""
        if not self.telegram_bot:
            logger.info(f"Telegram mesajÄ±: {message}")
            return False
            
        try:
            # Telegram bot kodu burada olacak
            logger.info(f"Telegram mesajÄ±: {message}")
            return True
        except Exception as e:
            logger.error(f"Telegram mesaj hatasÄ±: {str(e)}")
            return False
    
    def calculate_position_size(self, price: float, confidence: float) -> float:
        """Pozisyon bÃ¼yÃ¼klÃ¼ÄŸÃ¼nÃ¼ hesaplar"""
        base_position = self.current_capital * self.max_position_size
        confidence_multiplier = min(confidence * 2, 1.0)
        return base_position * confidence_multiplier
    
    def can_trade(self, symbol: str) -> bool:
        """Ä°ÅŸlem yapÄ±labilir mi kontrol eder"""
        # GÃ¼nlÃ¼k iÅŸlem sayÄ±sÄ± kontrolÃ¼
        today = datetime.now().date()
        today_trades = [t for t in self.trade_history if t['date'].date() == today]
        
        if len(today_trades) >= self.max_daily_trades:
            logger.warning(f"GÃ¼nlÃ¼k iÅŸlem limiti aÅŸÄ±ldÄ±: {symbol}")
            return False
        
        return True
    
    def open_position(self, symbol: str, price: float, confidence: float, 
                     prediction: int) -> bool:
        """Pozisyon aÃ§ar"""
        if not self.can_trade(symbol):
            return False
        
        if prediction != 1:  # Sadece yÃ¼kseliÅŸ sinyali iÃ§in pozisyon aÃ§
            return False
        
        if symbol in self.positions:
            logger.warning(f"Zaten pozisyon var: {symbol}")
            return False
        
        # Pozisyon bÃ¼yÃ¼klÃ¼ÄŸÃ¼nÃ¼ hesapla
        position_size = self.calculate_position_size(price, confidence)
        quantity = position_size / price
        
        # Sermaye kontrolÃ¼
        if position_size > self.current_capital:
            logger.warning(f"Yetersiz sermaye: {symbol}")
            return False
        
        # Pozisyonu aÃ§
        self.positions[symbol] = {
            'quantity': quantity,
            'entry_price': price,
            'entry_date': datetime.now(),
            'confidence': confidence
        }
        
        # Sermayeyi gÃ¼ncelle
        self.current_capital -= position_size
        
        # Ä°ÅŸlemi kaydet
        trade = {
            'date': datetime.now(),
            'symbol': symbol,
            'action': 'BUY',
            'price': price,
            'quantity': quantity,
            'position_size': position_size,
            'confidence': confidence,
            'capital_after': self.current_capital
        }
        
        self.trade_history.append(trade)
        
        # localStorage'a kaydet
        self.save_to_localStorage()
        
        # Log ve bildirim
        message = f"ðŸŸ¢ POZÄ°SYON AÃ‡ILDI\n{symbol}\nFiyat: {price:.2f} TL\nMiktar: {quantity:.0f}\nGÃ¼ven: {confidence:.2f}"
        logger.info(message)
        self.send_telegram_message(message)
        
        return True
    
    def close_position(self, symbol: str, price: float, reason: str = "Sinyal") -> bool:
        """Pozisyonu kapatÄ±r"""
        if symbol not in self.positions:
            return False
        
        position = self.positions[symbol]
        quantity = position['quantity']
        entry_price = position['entry_price']
        
        # Pozisyon deÄŸerini hesapla
        position_value = quantity * price
        
        # Sermayeyi gÃ¼ncelle
        self.current_capital += position_value
        
        # Getiri hesapla
        return_pct = (price - entry_price) / entry_price
        
        # Ä°ÅŸlemi kaydet
        trade = {
            'date': datetime.now(),
            'symbol': symbol,
            'action': 'SELL',
            'price': price,
            'quantity': quantity,
            'position_value': position_value,
            'return_pct': return_pct,
            'reason': reason,
            'capital_after': self.current_capital
        }
        
        self.trade_history.append(trade)
        
        # Pozisyonu kaldÄ±r
        del self.positions[symbol]
        
        # localStorage'a kaydet
        self.save_to_localStorage()
        
        # Log ve bildirim
        emoji = "ðŸŸ¢" if return_pct > 0 else "ðŸ”´"
        message = f"{emoji} POZÄ°SYON KAPATILDI\n{symbol}\nFiyat: {price:.2f} TL\nGetiri: {return_pct:.2%}\nSebep: {reason}"
        logger.info(message)
        self.send_telegram_message(message)
        
        return True
    
    def check_stop_loss_take_profit(self, symbol: str, current_price: float) -> Optional[str]:
        """Stop loss ve take profit kontrolÃ¼"""
        if symbol not in self.positions:
            return None
        
        position = self.positions[symbol]
        entry_price = position['entry_price']
        
        # Stop loss kontrolÃ¼
        if current_price <= entry_price * (1 - self.stop_loss_pct):
            return "Stop Loss"
        
        # Take profit kontrolÃ¼
        if current_price >= entry_price * (1 + self.take_profit_pct):
            return "Take Profit"
        
        return None
    
    def process_signal(self, symbol: str, current_price: float, 
                      prediction: int, confidence: float) -> Dict:
        """Sinyali iÅŸler"""
        result = {
            'action_taken': None,
            'reason': None,
            'success': False
        }
        
        # Mevcut pozisyon kontrolÃ¼
        if symbol in self.positions:
            # Stop loss / Take profit kontrolÃ¼
            sl_tp_reason = self.check_stop_loss_take_profit(symbol, current_price)
            if sl_tp_reason:
                success = self.close_position(symbol, current_price, sl_tp_reason)
                result['action_taken'] = 'CLOSE'
                result['reason'] = sl_tp_reason
                result['success'] = success
                return result
            
            # Model sinyali ile Ã§Ä±kÄ±ÅŸ
            if prediction == 0 and confidence > 0.50:  # DÃ¼ÅŸÃ¼ÅŸ sinyali (eÅŸik dÃ¼ÅŸÃ¼rÃ¼ldÃ¼)
                success = self.close_position(symbol, current_price, "DÃ¼ÅŸÃ¼ÅŸ Sinyali")
                result['action_taken'] = 'CLOSE'
                result['reason'] = "DÃ¼ÅŸÃ¼ÅŸ Sinyali"
                result['success'] = success
                return result
        
        # Yeni pozisyon aÃ§ma
        else:
            if prediction == 1 and confidence > 0.50:  # YÃ¼kseliÅŸ sinyali (eÅŸik dÃ¼ÅŸÃ¼rÃ¼ldÃ¼)
                success = self.open_position(symbol, current_price, confidence, prediction)
                result['action_taken'] = 'OPEN'
                result['reason'] = "YÃ¼kseliÅŸ Sinyali"
                result['success'] = success
        
        return result
    
    def get_current_price(self, symbol: str) -> float:
        """GerÃ§ek zamanlÄ± fiyat alÄ±r (cache ile optimize edilmiÅŸ)"""
        try:
            # Cache kontrolÃ¼
            now = datetime.now()
            if symbol in self.price_cache:
                cache_data = self.price_cache[symbol]
                cache_age = (now - cache_data['timestamp']).total_seconds()
                
                if cache_age < self.cache_duration:
                    logger.info(f"Cache'den fiyat alÄ±ndÄ±: {symbol} = {cache_data['price']:.2f} TL")
                    return cache_data['price']
            
            # Cache yoksa veya sÃ¼resi dolmuÅŸsa API'den Ã§ek
            import sys
            import os
            sys.path.append(os.path.join(os.path.dirname(__file__)))
            from data_loader import DataLoader
            
            loader = DataLoader(self.config)
            
            # Son 1 gÃ¼nlÃ¼k veri Ã§ek (gÃ¼ncel fiyat iÃ§in)
            data = loader.fetch_stock_data(symbol, "1d")
            
            if not data.empty:
                # Son kapanÄ±ÅŸ fiyatÄ±nÄ± al
                current_price = data['close'].iloc[-1]
                
                # Cache'e kaydet
                self.price_cache[symbol] = {
                    'price': float(current_price),
                    'timestamp': now
                }
                
                logger.info(f"GÃ¼ncel fiyat Ã§ekildi ve cache'e kaydedildi: {symbol} = {current_price:.2f} TL")
                return float(current_price)
            else:
                # Veri Ã§ekilemezse entry price'Ä± dÃ¶ndÃ¼r
                if symbol in self.positions:
                    entry_price = self.positions[symbol]['entry_price']
                    logger.warning(f"Veri Ã§ekilemedi, entry price kullanÄ±lÄ±yor: {symbol} = {entry_price:.2f} TL")
                    return entry_price
                else:
                    logger.warning(f"Veri Ã§ekilemedi ve pozisyon yok: {symbol}")
                    return 100.0  # VarsayÄ±lan fiyat
                    
        except Exception as e:
            logger.error(f"Fiyat Ã§ekme hatasÄ± {symbol}: {str(e)}")
            # Hata durumunda entry price'Ä± dÃ¶ndÃ¼r
            if symbol in self.positions:
                return self.positions[symbol]['entry_price']
            return 100.0
    
    def get_portfolio_summary(self) -> Dict:
        """PortfÃ¶y Ã¶zetini dÃ¶ndÃ¼rÃ¼r"""
        total_value = self.current_capital
        
        # Pozisyon deÄŸerlerini hesapla
        position_values = {}
        position_details = {}
        for symbol, position in self.positions.items():
            # GerÃ§ek zamanlÄ± fiyat alÄ±nmasÄ± gerekir (ÅŸimdilik entry price kullanÄ±yoruz)
            current_price = self.get_current_price(symbol)
            position_value = position['quantity'] * current_price
            position_values[symbol] = position_value
            total_value += position_value
            
            # Getiri hesapla
            unrealized_return = (current_price - position['entry_price']) / position['entry_price']
            
            # Pozisyon detaylarÄ±
            position_details[symbol] = {
                'quantity': position['quantity'],
                'entry_price': position['entry_price'],
                'current_price': current_price,
                'current_value': position_value,
                'unrealized_return': unrealized_return,
                'entry_date': position['entry_date'],
                'confidence': position['confidence'],
                'days_held': (datetime.now() - position['entry_date']).days
            }
        
        # Performans metrikleri
        total_return = (total_value - self.initial_capital) / self.initial_capital
        
        # Son iÅŸlemler
        recent_trades = self.trade_history[-5:] if self.trade_history else []
        
        # BugÃ¼nkÃ¼ iÅŸlemler
        today = datetime.now().date()
        today_trades = [t for t in self.trade_history if t['date'].date() == today]
        
        # En iyi ve en kÃ¶tÃ¼ iÅŸlemler
        profitable_trades = [t for t in self.trade_history if t.get('return_pct', 0) > 0]
        losing_trades = [t for t in self.trade_history if t.get('return_pct', 0) < 0]
        
        # PortfÃ¶y performans analizi
        portfolio_performance = self.calculate_portfolio_performance()
        
        summary = {
            'current_capital': self.current_capital,
            'total_value': total_value,
            'total_return': total_return,
            'positions': len(self.positions),
            'position_values': position_values,
            'position_details': position_details,
            'recent_trades': recent_trades,
            'total_trades': len(self.trade_history),
            'today_trades': len(today_trades),
            'profitable_trades': len(profitable_trades),
            'losing_trades': len(losing_trades),
            'win_rate': len(profitable_trades) / len(self.trade_history) if self.trade_history else 0,
            'portfolio_performance': portfolio_performance
        }
        
        return summary
    
    def calculate_portfolio_performance(self) -> Dict:
        """PortfÃ¶y performans analizi yapar"""
        if not self.trade_history:
            return {
                'total_profit_loss': 0,
                'avg_return_per_trade': 0,
                'best_trade': 0,
                'worst_trade': 0,
                'max_drawdown': 0,
                'sharpe_ratio': 0
            }
        
        # TamamlanmÄ±ÅŸ iÅŸlemlerden getiri hesapla
        completed_trades = [t for t in self.trade_history if 'return_pct' in t]
        
        if not completed_trades:
            return {
                'total_profit_loss': 0,
                'avg_return_per_trade': 0,
                'best_trade': 0,
                'worst_trade': 0,
                'max_drawdown': 0,
                'sharpe_ratio': 0
            }
        
        returns = [t['return_pct'] for t in completed_trades]
        
        # Temel metrikler
        total_profit_loss = sum(returns)
        avg_return_per_trade = np.mean(returns)
        best_trade = max(returns)
        worst_trade = min(returns)
        
        # Maksimum dÃ¼ÅŸÃ¼ÅŸ hesapla
        cumulative_returns = np.cumsum(returns)
        running_max = np.maximum.accumulate(cumulative_returns)
        drawdowns = running_max - cumulative_returns
        max_drawdown = np.max(drawdowns) if len(drawdowns) > 0 else 0
        
        # Sharpe ratio (basit versiyon)
        sharpe_ratio = avg_return_per_trade / np.std(returns) if np.std(returns) > 0 else 0
        
        return {
            'total_profit_loss': total_profit_loss,
            'avg_return_per_trade': avg_return_per_trade,
            'best_trade': best_trade,
            'worst_trade': worst_trade,
            'max_drawdown': max_drawdown,
            'sharpe_ratio': sharpe_ratio
        }
    
    def save_state(self):
        """Durumu kaydeder"""
        state = {
            'current_capital': self.current_capital,
            'positions': self.positions,
            'trade_history': self.trade_history,
            'timestamp': datetime.now().isoformat()
        }
        
        # PozisyonlarÄ± JSON serializable hale getir
        for symbol, pos in state['positions'].items():
            pos['entry_date'] = pos['entry_date'].isoformat()
        
        # Trade history'yi JSON serializable hale getir
        for trade in state['trade_history']:
            trade['date'] = trade['date'].isoformat()
        
        filepath = os.path.join(self.log_dir, f"paper_trader_state_{datetime.now().strftime('%Y%m%d')}.json")
        
        with open(filepath, 'w', encoding='utf-8') as f:
            json.dump(state, f, indent=2, ensure_ascii=False)
        
        logger.info(f"Durum kaydedildi: {filepath}")
    
    def load_state(self, filepath: str) -> bool:
        """Durumu yÃ¼kler"""
        try:
            with open(filepath, 'r', encoding='utf-8') as f:
                state = json.load(f)
            
            self.current_capital = state['current_capital']
            
            # PozisyonlarÄ± yÃ¼kle
            self.positions = {}
            for symbol, pos in state['positions'].items():
                self.positions[symbol] = {
                    'quantity': pos['quantity'],
                    'entry_price': pos['entry_price'],
                    'entry_date': datetime.fromisoformat(pos['entry_date']),
                    'confidence': pos['confidence']
                }
            
            # Trade history'yi yÃ¼kle
            self.trade_history = []
            for trade in state['trade_history']:
                trade['date'] = datetime.fromisoformat(trade['date'])
                self.trade_history.append(trade)
            
            logger.info(f"Durum yÃ¼klendi: {filepath}")
            return True
            
        except Exception as e:
            logger.error(f"Durum yÃ¼kleme hatasÄ±: {str(e)}")
            return False
    
    def generate_daily_report(self) -> str:
        """GÃ¼nlÃ¼k rapor oluÅŸturur"""
        summary = self.get_portfolio_summary()
        
        report = f"""
ðŸ“Š GÃœNLÃœK RAPOR - {datetime.now().strftime('%Y-%m-%d')}

ðŸ’° SERMAYE DURUMU:
- Mevcut Sermaye: {summary['current_capital']:,.0f} TL
- Toplam DeÄŸer: {summary['total_value']:,.0f} TL
- Toplam Getiri: {summary['total_return']:.2%}

ðŸ“ˆ POZÄ°SYONLAR ({summary['positions']} adet):
"""
        
        for symbol, value in summary['position_values'].items():
            position = self.positions[symbol]
            report += f"- {symbol}: {value:,.0f} TL (GiriÅŸ: {position['entry_price']:.2f})\n"
        
        report += f"""
ðŸ“‹ SON Ä°ÅžLEMLER:
"""
        
        for trade in summary['recent_trades']:
            emoji = "ðŸŸ¢" if trade['action'] == 'BUY' else "ðŸ”´"
            report += f"{emoji} {trade['date'].strftime('%H:%M')} - {trade['symbol']} - {trade['action']} - {trade['price']:.2f}\n"
        
        report += f"""
ðŸ“Š Ã–ZET:
- Toplam Ä°ÅŸlem: {summary['total_trades']}
- BugÃ¼nkÃ¼ Ä°ÅŸlem: {len([t for t in self.trade_history if t['date'].date() == datetime.now().date()])}
"""
        
        return report

class LiveSignalGenerator:
    def __init__(self, config: Dict):
        self.config = config
        self.paper_trader = PaperTrader(config)
        self.model = None
        self.scaler = None
        self.feature_columns = None
        
    def load_model(self, model_path: str) -> bool:
        """Modeli yÃ¼kler"""
        try:
            import joblib
            model_data = joblib.load(model_path)
            
            self.model = model_data['model']
            self.scaler = model_data['scaler']
            self.feature_columns = model_data['feature_columns']
            
            logger.info(f"Model yÃ¼klendi: {model_path}")
            return True
            
        except Exception as e:
            logger.error(f"Model yÃ¼kleme hatasÄ±: {str(e)}")
            return False
    
    def generate_signals(self, symbols: List[str]) -> Dict[str, Dict]:
        """TÃ¼m semboller iÃ§in sinyal Ã¼retir"""
        signals = {}
        
        for symbol in symbols:
            try:
                # Veri yÃ¼kle
                from data_loader import DataLoader
                from feature_engineering import FeatureEngineer
                
                loader = DataLoader(self.config)
                engineer = FeatureEngineer(self.config)
                
                # Son 30 gÃ¼nlÃ¼k veri
                data = loader.fetch_stock_data(symbol, "30d")
                
                if data.empty:
                    logger.warning(f"Veri bulunamadÄ±: {symbol}")
                    continue
                
                # Ã–zellikleri oluÅŸtur
                features_df = engineer.create_all_features(data)
                
                if features_df.empty:
                    logger.warning(f"Ã–zellik oluÅŸturulamadÄ±: {symbol}")
                    continue
                
                # Son gÃ¼nÃ¼n Ã¶zelliklerini al
                latest_features = features_df[self.feature_columns].iloc[-1:].copy()
                
                # Tahmin yap
                prediction, probabilities = self.model.predict(latest_features)
                confidence = np.abs(probabilities[0][1] - 0.5) * 2  # 0-1 arasÄ± normalize
                
                # Mevcut fiyat
                current_price = data['close'].iloc[-1]
                
                # Sinyali iÅŸle
                result = self.paper_trader.process_signal(
                    symbol, current_price, prediction[0], confidence
                )
                
                signals[symbol] = {
                    'prediction': prediction[0],
                    'confidence': confidence,
                    'current_price': current_price,
                    'action_taken': result['action_taken'],
                    'reason': result['reason'],
                    'success': result['success']
                }
                
                logger.info(f"Sinyal Ã¼retildi: {symbol} - Tahmin: {prediction[0]} - GÃ¼ven: {confidence:.2f}")
                
            except Exception as e:
                logger.error(f"Sinyal Ã¼retme hatasÄ± {symbol}: {str(e)}")
                signals[symbol] = None
        
        return signals
    
    def run_daily_signal_generation(self):
        """GÃ¼nlÃ¼k sinyal Ã¼retimi Ã§alÄ±ÅŸtÄ±rÄ±r"""
        logger.info("GÃ¼nlÃ¼k sinyal Ã¼retimi baÅŸlÄ±yor...")
        
        symbols = self.config.get('TARGET_STOCKS', [])
        signals = self.generate_signals(symbols)
        
        # Ã–zet raporu gÃ¶nder
        summary = self.paper_trader.get_portfolio_summary()
        daily_report = self.paper_trader.generate_daily_report()
        
        # Telegram'a gÃ¶nder
        self.paper_trader.send_telegram_message(daily_report)
        
        # Durumu kaydet
        self.paper_trader.save_state()
        
        logger.info("GÃ¼nlÃ¼k sinyal Ã¼retimi tamamlandÄ±")

def main():
    """Test fonksiyonu"""
    import yaml
    
    # Config yÃ¼kle
    with open('config.yaml', 'r', encoding='utf-8') as f:
        config = yaml.safe_load(f)
    
    # Paper trader oluÅŸtur
    trader = PaperTrader(config)
    
    # Test sinyali
    result = trader.process_signal("THYAO.IS", 100.0, 1, 0.8)
    print(f"Ä°ÅŸlem sonucu: {result}")
    
    # PortfÃ¶y Ã¶zeti
    summary = trader.get_portfolio_summary()
    print(f"PortfÃ¶y Ã¶zeti: {summary}")
    
    # GÃ¼nlÃ¼k rapor
    report = trader.generate_daily_report()
    print(report)

if __name__ == "__main__":
    main()

